//
//  NodeCD.swift
//  LedgerLinkV2
//
//  Created by J C on 2022-02-20.
//

/*
 Abstract:
 Node Core Data saves and queries TreeConfigurableAccounts, TreeConfigurableTransactions, and TreeConfigurableReceipts.
 It also creates a new block. It performs the same tasks as NodeDB except not in-memory, but with Core Data.
 */

import Foundation
import web3swift
import Combine
import BigInt
import MultipeerConnectivity

protocol NodeConfigurable {
    func search(_ data: TreeConfigurableAccount) -> TreeConfigurableAccount?
    func search(_ data: Account) throws -> TreeConfigurableAccount?
    func search(_ addressString: String) -> Account?
    func search(_ data: TreeConfigurableTransaction) -> TreeConfigurableTransaction?
    func search(_ data: TreeConfigurableReceipt) -> TreeConfigurableReceipt?
    func addData(_ data: TreeConfigurableAccount)
    func addData(_ data: Account) throws
    func addData(_ data: [TreeConfigurableAccount])
    func addData(_ data: TreeConfigurableTransaction)
    func addData(_ data: [TreeConfigurableTransaction])
    func addData(_ data: TreeConfigurableReceipt)
    func addData(_ data: [TreeConfigurableReceipt])
    func transfer(_ treeConfigTransaction: TreeConfigurableTransaction) throws
    func transfer(_ encoded: TreeConfigurableTransaction, decoded: EthereumTransaction) throws
    func getMyAccount() throws -> Account?
}

/// Received transactions are parsed into TimestampedOperation format and added to the pool (validatedOperations) to be executed sequentially.
struct TimestampedOperation {
    let timestamp: Date
    let operation: AsyncOperation
}

@available(iOS 15.0.0, *)
final class Node {
    static let shared = Node()
    let localStorage = LocalStorage()
    private var storage = Set<AnyCancellable>()
    private(set) var validatedOperations: [TimestampedOperation] = [] /// validated transactions to be added to the queue and executed in order
    private(set) var validatedTransactions: [TreeConfigurableTransaction] = [] /// validated transactions to be added to the upcoming block
    private(set) var validatedAccounts: [TreeConfigurableAccount] = [] /// updated accounts after the transfer to be added to the block
    private(set) var unvalidatedBlocks: Multiset<FullBlock> = [] /// receive blocks from peers and blocks generated by your own device prior to being added to the blockchain. Multiset keeps tally of each unique blocks.
    private let queue = OperationQueue() /// Queue executes transactions in timestamped order sequentially
    
    func save<T: LightConfigurable>(_ element: T, completion: @escaping (NodeError?) -> Void) async {
        await localStorage.save(element, completion: completion)
    }
    
    func save<T>(_ element: T, completion: @escaping (NodeError?) -> Void) async {
        await localStorage.save(element, completion: completion)
    }
    
    func save<T: LightConfigurable>(_ elements: [T], completion: @escaping (NodeError?) -> Void) async {
        await localStorage.save(elements, completion: completion)
    }
    
    func save<T>(_ element: [T], completion: @escaping (NodeError?) -> Void) async {
        await localStorage.save(element, completion: completion)
    }
    
    func saveSync<T>(_ elements: [T], completion: @escaping (NodeError?) -> Void) {
        localStorage.saveSync(elements, completion: completion)
    }
    
    func saveSync<T: LightConfigurable>(_ elements: [T], completion: @escaping (NodeError?) -> Void) {
        localStorage.saveSync(elements, completion: completion)
    }
    
    func fetch<T: CoreDatable>(_ predicateString: String? = nil, completion: @escaping ([T]?, NodeError?) -> Void) {
        localStorage.fetch(predicateString, completion: completion)
    }
    
    func delete<T: CoreDatable>(_ element: T) {
        localStorage.delete(element)
    }
    
    func deleteAll(of entity: LocalStorage.EntityName) {
        localStorage.deleteAll(of: entity)
    }
    
    func deleteAll() {
        localStorage.deleteAll()
    }
    
    /*
     1. Subtract the value from the sender's balance.
     2. Add the value to the recipient's balance.
     3. Update both accounts with the updated balances to Core Data.
     */
    func transfer(transaction: EthereumTransaction) {
        guard let address = transaction.sender?.address else { return }
        
        Deferred {
            /// Sender's account. Subtract the value from the sender's balance
            Future<Account, NodeError> { [weak self] promise in
                self?.fetch(address) { (accounts: [Account]?, error: NodeError?) in
                    if let error = error {
                        promise(.failure(error))
                    }
                    
                    guard let accounts = accounts,
                          var account = accounts.first else {
                              promise(.failure(NodeError.generalError("Unable to find the account")))
                        return
                    }
                    
                    guard let value = transaction.value,
                          account.balance >= value else {
                              promise(.failure(NodeError.generalError("Not enough balance")))
                        return
                    }
                    
                    account.balance -= value
                    promise(.success(account))
                }
            }
            .eraseToAnyPublisher()
        }
        .flatMap { [weak self] (sender) -> AnyPublisher<[Account], NodeError> in
            /// Recipient's account. Add the value to the balance
            Future<[Account], NodeError> { promise in
                self?.fetch(transaction.to.address) { (accounts: [Account]?, error: NodeError?) in
                    if let error = error {
                        promise(.failure(error))
                    }
                    
                    /// If the account exists, update the amount. If not, create a new one.
                    if let accounts = accounts,
                       var recipient = accounts.first,
                       let value = transaction.value {
                        recipient.balance += value
                        let finalAccounts = [sender, recipient]
                        promise(.success(finalAccounts))
                    } else {
                        let password = Int.random(in: 1000...9999)
                        guard let newWallet = try? EthereumKeystoreV3(password: "\(password)") else {
                            promise(.failure(.generalError("Unable to generate a new address")))
                            return
                        }
                        
                        guard let address = newWallet.addresses?.first else {
                            promise(.failure(.generalError("Unable to generate a new address")))
                            return
                        }
                        
                        guard let value = transaction.value else {
                            promise(.failure(.generalError("Unable to generate get the sent balance")))
                            return
                        }
                        
                        let recipient = Account(address: address, nonce: 0, balance: value)
                        let finalAccounts = [sender, recipient]
                        promise(.success(finalAccounts))
                    }
                }
            }
            .eraseToAnyPublisher()
        }
        .sink(receiveCompletion: { completion in
            switch completion {
                case .failure(let error):
                    print("error in transfer value", error)
                    break
                case .finished:
                    print("finished in transfer value")
                    break
            }
        }, receiveValue: { [weak self] (accounts) in
            /// Accounts to be added to a block
            self?.addValidatedAccounts(accounts)
            
            /// Save both accounts with the updated balances
            Node.shared.saveSync(accounts, completion: { error in
                if let error = error {
                    print(error)
                }
                print("Save both accounts with the updated balances")
            })
        })
        .store(in: &storage)
    }
    
    func getMyAccount(completion: @escaping (Account?, NodeError?) -> Void) {
        do {
            let wallet = try localStorage.getWallet()
            guard let address = wallet?.address else { return }
            fetch(address) { (accounts: [Account]?, error: NodeError?) in
                if let _ = error {
                    completion(nil, NodeError.generalError("Unable to fetch the wallet"))
                }
                
                if let accounts = accounts, let account = accounts.first {
                    completion(account, nil)
                }
            }
        } catch {
            completion(nil, NodeError.generalError("Unable to fetch the address"))
        }
    }
    
    /// Creating a block requires multiple steps.
    /// Process the last block by choosing one from the pool.
    func createBlock(completion: @escaping (LightBlock) -> Void) {
        Deferred {
            /// Select the majority block from a pool of pending blocks
            Future<FullBlock?, NodeError> { [weak self] promise in
                Node.shared.localStorage.getLatestBlock { (lastBlock: FullBlock?, error: NodeError?) in
                    if let error = error {
                        promise(.failure(error))
                        return
                    }

                    /// No last block has to exists to compare the new block's parent hash and the block number against
                    guard let lastBlock = lastBlock else {
                        promise(.success(nil))
                        return
                    }

                    /// Select the block from the pool with the most tally.  There should be at least one block created locally
                    guard let newBlock = self?.unvalidatedBlocks.maxItem() else {
                        promise(.failure(NodeError.generalError("Unable to determine the new block to be added")))
                        return
                    }

                    if (newBlock.number == (lastBlock.number + 1)) && (newBlock.parentHash == lastBlock.hash) {
                        print("correct block!")
                        /// Correct block to be saved
                        /// Save the transactions, accounts, and a block in a relational way
                        Node.shared.localStorage.saveRelationalBlock(block: newBlock) { error in
                            /// Now that a valid block has been selected remove all old blocks
                            Node.shared.unvalidatedBlocks.removeAll()
                            
                            if let error = error {
                                promise(.failure(error))
                            } else {
                                promise(.success(newBlock))
                            }
                        }
                    } else {
                        print("incorrect block!")
                    }
                }
            }
            .eraseToAnyPublisher()
        }
        .flatMap({ (lastBlock) -> AnyPublisher<FullBlock?, NodeError> in
            /// The newly saved block becomes the last block for the next block.
            /// Execute all the transactions in order by sorting them by the timestamp first and adding them to a queue
            return Future<FullBlock?, NodeError> { [weak self] promise in
                guard let sorted = self?.validatedOperations.sorted (by: { $0.timestamp < $1.timestamp }) else {
                    promise(.failure(.generalError("Unable to sort the timestamped operations")))
                    return
                }
                let operations = sorted.compactMap { $0.operation }
                self?.queue.addOperations(operations, waitUntilFinished: true)
                self?.validatedOperations.removeAll()
                promise(.success(lastBlock))
            }
            .eraseToAnyPublisher()
        })
        .flatMap({ [weak self] (lastBlock) -> AnyPublisher<LightBlock, NodeError> in
            Future<LightBlock, NodeError> { promise in
                guard let self = self else {
                    promise(.failure(NodeError.generalError("Unable to create a new block")))
                    return
                }

                /// Create the stateRoot and transactionRoot from the validated data using the Merkle tree.
                let accountArr = self.validatedAccounts.map { $0.data }
                let txDataArr = self.validatedTransactions.map { $0.data }

                self.getMyAccount { account, error in
                    if let error = error {
                        promise(.failure(error))
                    }
                    
                    guard let account = account else {
                        return
                    }
                    
                    do {
                        /// Use default data if no validated transactions or account exist to create the merkle root hash
                        let defaultString = "0x0000000000000000000000000000000000000000"
                        guard let defaultData = defaultString.data(using: .utf8) else {
                            promise(.failure(NodeError.generalError("Unable to create a new block")))
                            return
                        }
                        
                        /// Create a state root hash
                        let accArr = accountArr.count > 0 ? accountArr : [defaultData]
                        guard case .Node(hash: let stateRoot, datum: _, left: _, right: _) = try MerkleTree.buildTree(fromData: accArr) else {
                            fatalError()
                        }
                        
                        /// Create a transaction root hash
                        let txArr = txDataArr.count > 0 ? txDataArr : [defaultData]
                        guard case .Node(hash: let transactionsRoot, datum: _, left: _, right: _) = try MerkleTree.buildTree(fromData: txArr) else {
                            fatalError()
                        }
                        
                        var blockNumber: BigUInt!
                        var parentHash: Data!
                        
                        /// Use the previous block if it exists
                        if let lastBlock = lastBlock {
                            blockNumber = lastBlock.number
                            parentHash = lastBlock.hash
                        } else {
                            /// Last block doesn't exist which means the current block is a genesis block
                            blockNumber = BigUInt(0)
                            parentHash = Data()
                        }
                                                
                        /// Create a new block
                        let newBlock = try FullBlock(number: blockNumber + 1, parentHash: parentHash, nonce: nil, transactionsRoot: transactionsRoot, stateRoot: stateRoot, receiptsRoot: Data(), extraData: nil, gasLimit: nil, gasUsed: nil, miner: account.address.address, transactions: self.validatedTransactions, accounts: self.validatedAccounts)
                        /// The newly created block becomes the unvalidated block to be sent out and also be verified next against a pool of other candidates.
                        self.addUnvalidatedBlock(newBlock)
                        
                        let lightBlock = try LightBlock(data: newBlock)
                        promise(.success(lightBlock))
                        
                    } catch {
                        promise(.failure(.generalError("Unable to create a new block")))
                    }
                }
            }
            .eraseToAnyPublisher()
        })
        .sink { completion in
            switch completion {
                case .finished:
                    print("block created")
                case .failure(let error):
                    print("block creation error", error)
            }
        } receiveValue: { [weak self] (block) in
            self?.validatedTransactions.removeAll()
            self?.validatedAccounts.removeAll()
            completion(block)
        }
        .store(in: &storage)
    }
    
    func mintGenesisBlock(completion: @escaping (NodeError?) -> Void) {
        let defaultString = "0x0000000000000000000000000000000000000000"
        guard let defaultData = defaultString.data(using: .utf8) else {
            return
        }

        getMyAccount { [weak self] (account, error) in
            if let error = error {
                completion(error)
            }

            guard let account = account else {
                return
            }

            do {
                guard case .Node(hash: let stateRoot, datum: _, left: _, right: _) = try MerkleTree.buildTree(fromData: [defaultData]) else {
                    fatalError()
                }

                guard case .Node(hash: let transactionsRoot, datum: _, left: _, right: _) = try MerkleTree.buildTree(fromData: [defaultData]) else {
                    fatalError()
                }

                let genesisBlock = try FullBlock(number: 0, parentHash: Data(), nonce: nil, transactionsRoot: transactionsRoot, stateRoot: stateRoot, receiptsRoot: Data(), extraData: nil, gasLimit: nil, gasUsed: nil, miner: account.address.address, transactions: nil, accounts: nil)

                /// Second block is needed because a block creation only begins when two consecutive blocks are compared
                let secondBlock = try FullBlock(number: 1, parentHash: genesisBlock.hash, nonce: nil, transactionsRoot: transactionsRoot, stateRoot: stateRoot, receiptsRoot: Data(), extraData: nil, gasLimit: nil, gasUsed: nil, miner: account.address.address, transactions: nil, accounts: nil)

                /// Genesis block is saved because it requires no validation
                self?.saveSync([genesisBlock]) { (error) in
                    if let error = error {
                        completion(error)
                    }

                    /// Second block is added to the unvalidated pool since it has to be compared to the genesis block
                    self?.addUnvalidatedBlock(secondBlock)

                    completion(nil)
                }
            } catch {
                guard let error = error as? NodeError else { return }
                completion(error)
            }
        }

    }
    
    func addValidatedOperation(_ operation: TimestampedOperation) {
        self.validatedOperations.append(operation)
    }
    
    func addValidatedTransaction(_ rlpData: Data) {
        guard let treeConfigTx = try? TreeConfigurableTransaction(rlpTransaction: rlpData) else { return }
        self.validatedTransactions.append(treeConfigTx)
        
        let transactionHash = treeConfigTx.id
        /// Validate the transaction by checking for duplicates in the waiting pool
        let duplicates = validatedTransactions.filter ({ $0.id == transactionHash })
        guard duplicates.count == 0 else {
            return
        }

        /// Validate the transaction by checking for duplicates in the blockchain
        Node.shared.fetch(transactionHash) { [weak self] (txs: [EthereumTransaction]?, error: NodeError?) in
            if let _ = error {
                return
            }


            /// No matching transaction exists in Core Data so proceed to process the transaction
            guard let txs = txs, txs.count == 0  else {
                return
            }

            self?.validatedTransactions.append(treeConfigTx)
        }
    }
    
    func addValidatedTransaction(_ transaction: EthereumTransaction) {
        guard let treeConfigTx = try? TreeConfigurableTransaction(data: transaction) else { return }
        self.validatedTransactions.append(treeConfigTx)

        let transactionHash = treeConfigTx.id
        /// Validate the transaction by checking for duplicates in the waiting pool
        let duplicates = validatedTransactions.filter ({ $0.id == transactionHash })
        guard duplicates.count == 0 else {
            return
        }

        /// Validate the transaction by checking for duplicates in the blockchain
        Node.shared.fetch(transactionHash) { [weak self] (txs: [EthereumTransaction]?, error: NodeError?) in
            if let _ = error {
                return
            }


            /// No matching transaction exists in Core Data so proceed to process the transaction
            guard let txs = txs, txs.count == 0  else {
                return
            }

            self?.validatedTransactions.append(treeConfigTx)
        }
    }
    
    func addValidatedAccount(_ account: Account) {
        guard let treeConfigAcct = try? TreeConfigurableAccount(data: account) else { return }
        validatedAccounts.append(treeConfigAcct)
    }

    func addValidatedAccounts(_ accounts: [Account]) {
        accounts.forEach { addValidatedAccount($0) }
    }

    func addUnvalidatedBlock(_ block: FullBlock) {
        unvalidatedBlocks.add(block)
    }

    /// Process the transactions received from peers according to the contract methods.
    func processTransaction(_ data: Data, peerID: MCPeerID) {
        do {
            let decoded = try JSONDecoder().decode(ContractMethod.self, from: data)
            switch decoded {
                case .createAccount(let rlpData):
                    NetworkManager.shared.relayTransaction(data: data, peerID: peerID)
                    validateTransaction(rlpData) { [weak self] (result, error) in
                        if let transaction = result.0,
                           let extraData = result.1 {
                            let createAccount = CreateAccount(extraData: extraData)
                            let timestamp = extraData.timestamp
                            /// Add the operations to be sorted according to the timestamp and to be executed in order
                            self?.validatedOperations.append(TimestampedOperation(timestamp: timestamp, operation: createAccount))
                            /// Add the transactions to be added to the upcoming block
                            guard let treeConfigTx = try? TreeConfigurableTransaction(data: transaction) else { return }
                            self?.validatedTransactions.append(treeConfigTx)
                        }
                    }
                    break
                case .transferValue(let rlpData):
                    NetworkManager.shared.relayTransaction(data: data, peerID: peerID)
                    validateTransaction(rlpData) { [weak self] (result, error) in
                        if let transaction = result.0,
                           let extraData = result.1 {
                            let transferValueOperation = TransferValueOperation(transaction: transaction)
                            let timestamp = extraData.timestamp
                            /// Add the operations to be sorted according to the timestamp and to be executed in order
                            self?.validatedOperations.append(TimestampedOperation(timestamp: timestamp, operation: transferValueOperation))
                            /// Add the transactions to be added to the upcoming block
                            guard let treeConfigTx = try? TreeConfigurableTransaction(data: transaction) else { return }
                            self?.validatedTransactions.append(treeConfigTx)
                        }
                    }
                    break
                case .blockchainDownloadRequest(let blockNumber):
                    /// Blockchain request by the sender. Therefore, send the requested blockchain.
                    /// Usually requested when an account is newly created
                    NetworkManager.shared.sendBlockchain(blockNumber, format: "number > %i", peerID: peerID)
                    break
                case .blockchainDownloadResponse(let packet):
                    /// Parse the requested blockchain
                    /// Non-transactions don't have to go through the queue such as the blockchain data sent from peers as a response to the request to update the local blockchain
                    /// Blockchain data received from peers to update the local blockchain.  This means your device has requested the blockchain info from another peer either during the creation of wallet or during the contract method execution.
                    parsePacket(packet)
                    break
                case .sendBlock(let data):
                    /// Light blocks sent from peers on a regular interval
                    NetworkManager.shared.relayBlock(data)
                    guard let decompressed = data.decompressed else { return }
                    let decoded = try JSONDecoder().decode(LightBlock.self, from: decompressed)
                    parseBlock(decoded)
                    break
                case .blockchainDownloadAllRequest:
                    /// Request a complete blockchain.
                    /// This is used when a new block to be added is incompatible with the local blockchain and needs a complete overhaul.
                    NetworkManager.shared.sendBlockchain(Int32(0), format: "number > %i", peerID: peerID)
                    break
                case .blockchainDownloadAllResponse(let packet):
                    deleteAll()

                    break
            }
        } catch {
            print("error in didReceive", error)
        }
    }

    /// What is a valid transaction?
    ///  1. The recovered public key should match the sender.
    ///  2. The transaction should not already exist in the blockchain.
    ///  3. The transaction should not already exist among validated transaction pool to be added to the upcoming block (no duplicted allowed).
    private func validateTransaction(_ rlpData: Data, completion: @escaping ((EthereumTransaction?, TransactionExtraData?), NodeError?) -> Void)  {
        /// 1. Validate the transaction by recovering the public key.
        guard let decodedTx = EthereumTransaction.fromRaw(rlpData),// RLP -> EthereumTransaction
              let publicKey = decodedTx.recoverPublicKey(),
              let senderAddress = Web3.Utils.publicToAddressString(publicKey),
              let senderAddressToBeCompared = decodedTx.sender?.address,
              senderAddress == senderAddressToBeCompared.lowercased(), // If the two info are different, discard the transaction.
              let decodedExtraData = try? JSONDecoder().decode(TransactionExtraData.self, from: decodedTx.data),
              let compressed = rlpData.compressed else {
                  completion((nil, nil), .generalError("Unable to validate the transaction"))
                  return
              }

        let chainID = UserDefaults.standard.integer(forKey: "chainID")
        guard decodedTx.intrinsicChainID == BigUInt(chainID) else {
            completion((nil, nil), .generalError("Incorrect chain ID"))
            return
        }

        let transactionHash = compressed.sha256().toHexString()
        /// 2. Validate the transaction by checking for duplicates in the waiting pool
        let duplicates = validatedTransactions.filter ({ $0.id == transactionHash })
        guard duplicates.count == 0 else {
            completion((nil, nil), .generalError("Duplicate transaction exists"))
            return
        }

        /// 3. Validate the transaction by checking for duplicates in the blockchain
        Node.shared.fetch(transactionHash) { (txs: [EthereumTransaction]?, error: NodeError?) in
            if let error = error {
                print("fetch error", error)
                completion((nil, nil), error)
                return
            }


            /// No matching transaction exists in Core Data so proceed to process the transaction
            guard let txs = txs, txs.count == 0  else {
                completion((nil, nil), .generalError("Duplicate transaction exists in the blockchain"))
                return
            }

            completion((decodedTx, decodedExtraData), nil)
        }
    }

    /// Parses Packet which consists of an array of TreeConfigAccts, TreeConfigTxs, and lightBlocks.
    /// The packets are sent as a response to a request for a portion of or a full blockchain by peers
    func parsePacket(_ packet: Packet) {
        /// Calculate the blocks that don't exist locally and save them.
        if let blocks = packet.blocks, blocks.count > 0 {
            Node.shared.localStorage.getLatestBlock { (block: LightBlock?, error: NodeError?) in
                if let error = error {
                    print(error)
                    return
                }

                if let block = block {
                    /// Only save the blocks that are greater in its block number than then the already existing blocks.
                    let nonExistingBlocks = blocks.filter { $0.number > block.number }
                    /// There is a chance that the local blockchain size might have increased during the transfer. If so, ignore the received block
                    if nonExistingBlocks.count > 0 {
                        Node.shared.saveSync(nonExistingBlocks) { error in
                            if let error = error {
                                print(error)
                                return
                            }
                        }
                    }
                } else {
                    /// no local blockchain exists yet because it's a brand new account
                    /// delete potentially existing ones since no transactions could've/should've been occured
                    Node.shared.deleteAll(of: .blockCoreData)
                    Node.shared.saveSync(blocks) { error in
                        if let error = error {
                            print("block save error", error)
                            return
                        }
                    }
                }
            }
        } else {
            /// The request for blockchain returned null which could potentially mean the blockchain is at a beginning stage so mint a genesis block.
            self.mintGenesisBlock(completion: { error in
                if let error = error {
                    print("genesis block", error)
                }
            })
        }

        /// Save the transactions.
        if let transactions = packet.transactions, transactions.count > 0 {
            Node.shared.saveSync(transactions) { error in
                if let error = error {
                    print("transaction save error", error)
                    return
                }
            }
        }

        /// Save the accounts.
        if let accounts = packet.accounts, accounts.count > 0 {
            Node.shared.saveSync(accounts) { error in
                if let error = error {
                    print("accounts save error", error)
                    return
                }
            }
        }
    }
    
    /// Calculate the block hash for each block and verify that the latest block has the correct hash
    /// This method is usually executed when you receive the blockchain from peers.
    func verifyEachBlock(_ blocks: [LightBlock]) -> Bool? {
        var isValid = true
        for i in 0 ..< blocks.count - 1 {
            guard let fullBlock = blocks[i].decode(),
                  let nextBlock = blocks[i + 1].decode() else { return nil }
            let blockHash = try? fullBlock.generateBlockHash()
            if (fullBlock.hash == blockHash) && (nextBlock.parentHash == blockHash) {
                continue
            } else {
                isValid = false
                break
            }
        }
        
        return isValid
    }

    /// Receive the block sent from peers
    /// Select the block with the most tally
    func parseBlock(_ block: LightBlock) {
        guard let fullBlock = block.decode() else { return }
        unvalidatedBlocks.add(fullBlock)
    }
}

#if DEBUG
extension Node {
    func exposeValidateTransaction(_ rlpData: Data, completion: @escaping ((EthereumTransaction?, TransactionExtraData?), NodeError?) -> Void) {
        return validateTransaction(rlpData, completion: completion)
    }
}
#endif
